<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Content Board - We Want Waste</title>
    <style>
        /* [Previous CSS - keeping it the same] */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f5f5f5; padding: 20px; }
        .header { text-align: center; margin-bottom: 20px; }
        h1 { color: #333; margin-bottom: 10px; }
        .stats { font-size: 14px; color: #666; }
        .board { display: flex; gap: 15px; overflow-x: auto; padding-bottom: 20px; }
        .column { min-width: 280px; max-width: 280px; background: #fff; border-radius: 12px; padding: 15px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); min-height: 400px; }
        .column.drag-over { background: #e3f2fd; }
        .column h2 { font-size: 14px; text-transform: uppercase; color: #666; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 2px solid #eee; }
        .column.ideas h2 { border-color: #9e9e9e; }
        .column.writing h2 { border-color: #2196f3; }
        .column.review h2 { border-color: #ff9800; }
        .column.scheduled h2 { border-color: #9c27b0; }
        .column.published h2 { border-color: #4caf50; }
        .card { background: #fafafa; border-radius: 8px; padding: 12px; margin-bottom: 10px; cursor: move; border-left: 3px solid #ddd; transition: all 0.2s; user-select: none; -webkit-user-select: none; touch-action: none; }
        .card:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
        .card.dragging { opacity: 0.5; }
        .card.high-priority { border-left-color: #f44336; }
        .card.generating { border-left-color: #2196f3; animation: pulse 2s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        .card-title { font-weight: 600; font-size: 14px; margin-bottom: 8px; color: #333; }
        .card-meta { display: flex; gap: 10px; font-size: 11px; color: #888; flex-wrap: wrap; }
        .card-meta span { background: #eee; padding: 2px 8px; border-radius: 10px; }
        .card-meta .status-badge { background: #2196f3; color: white; font-weight: 600; }
        .loading { text-align: center; padding: 40px; color: #888; }
        .error { text-align: center; padding: 40px; color: #f44336; background: #ffebee; border-radius: 8px; margin: 20px; }
    </style>
</head>
<body>
    <div class="header">
        <h1>üìã Content Board</h1>
        <div class="stats" id="stats">Loading...</div>
    </div>
    
    <div class="board" id="board">
        <div class="loading">Loading content ideas...</div>
    </div>

    <script>
        const SUPABASE_URL = 'https://zppiksmyqnigiziqsigq.supabase.co';
        const SUPABASE_KEY = 'sb_publishable_4xGNFr6q9Fv-_4tg4SVYRw_0D4nnSGz';
        
        let allIdeas = [];
        let draggedCard = null;
        
        // Load content from call_insights
        async function loadContentIdeas() {
            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/call_insights?select=*`, {
                    headers: {
                        'apikey': SUPABASE_KEY,
                        'Authorization': `Bearer ${SUPABASE_KEY}`
                    }
                });
                
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const calls = await response.json();
                
                // Extract content angles
                allIdeas = [];
                calls.forEach(call => {
                    try {
                        const angles = typeof call.content_angles === 'string' 
                            ? JSON.parse(call.content_angles)
                            : call.content_angles || [];
                        
                        angles.forEach((angle, idx) => {
                            const ideaId = `${call.call_id}-${idx}`;
                            const savedStatus = localStorage.getItem(`card-status-${ideaId}`) || 'ideas';
                            const savedContent = localStorage.getItem(`card-content-${ideaId}`);
                            
                            allIdeas.push({
                                id: ideaId,
                                call_id: call.call_id,
                                index: idx,
                                title: angle.hook || angle.topic_detail || 'Untitled',
                                format: angle.format || 'blog_post',
                                audience: angle.target_audience || 'unknown',
                                topic: angle.topic_category || 'other',
                                priority: call.priority_score || 5,
                                status: savedStatus,
                                generated_content: savedContent,
                                details: angle
                            });
                        });
                    } catch (e) {}
                });
                
                renderBoard();
                updateStats();
                startPolling();
                
            } catch (error) {
                document.getElementById('board').innerHTML = `
                    <div class="error">
                        <h2>‚ùå Error Loading Data</h2>
                        <p>${error.message}</p>
                    </div>
                `;
            }
        }

        function renderBoard() {
            const columns = {
                ideas: { title: 'üí° IDEAS', items: [] },
                writing: { title: '‚úçÔ∏è WRITING', items: [] },
                review: { title: 'üëÄ REVIEW', items: [] },
                scheduled: { title: 'üìÖ SCHEDULED', items: [] },
                published: { title: '‚úÖ PUBLISHED', items: [] }
            };

            allIdeas.forEach(idea => {
                const status = idea.status || 'ideas';
                if (columns[status]) columns[status].items.push(idea);
            });

            const boardHTML = Object.entries(columns).map(([key, col]) => `
                <div class="column ${key}" data-column="${key}">
                    <h2>${col.title} (${col.items.length})</h2>
                    ${col.items.map(item => {
                        const isGenerating = item.status === 'writing' && !item.generated_content;
                        return `
                        <div class="card ${item.priority >= 7 ? 'high-priority' : ''} ${isGenerating ? 'generating' : ''}" 
                             data-id="${item.id}" 
                             draggable="true">
                            <div class="card-title">${item.title}</div>
                            <div class="card-meta">
                                <span>${item.format}</span>
                                <span>${item.audience}</span>
                                <span>P${item.priority}</span>
                                ${isGenerating ? '<span class="status-badge">Generating...</span>' : ''}
                            </div>
                        </div>
                    `}).join('')}
                </div>
            `).join('');

            document.getElementById('board').innerHTML = boardHTML;
            initDragAndDrop();
        }

        function initDragAndDrop() {
            const cards = document.querySelectorAll('.card');
            const columns = document.querySelectorAll('.column');
            let touchStartY = 0;
            let touchStartX = 0;

            cards.forEach(card => {
                // Mouse events (desktop)
                card.addEventListener('dragstart', e => {
                    draggedCard = card;
                    card.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                });

                card.addEventListener('dragend', () => {
                    card.classList.remove('dragging');
                    draggedCard = null;
                });

                // Touch events (mobile)
                card.addEventListener('touchstart', e => {
                    draggedCard = card;
                    card.classList.add('dragging');
                    touchStartY = e.touches[0].clientY;
                    touchStartX = e.touches[0].clientX;
                }, { passive: true });

                card.addEventListener('touchmove', e => {
                    if (!draggedCard) return;
                    
                    const touch = e.touches[0];
                    const elementAtPoint = document.elementFromPoint(touch.clientX, touch.clientY);
                    const targetColumn = elementAtPoint?.closest('.column');
                    
                    // Remove drag-over from all columns
                    columns.forEach(col => col.classList.remove('drag-over'));
                    
                    // Add to current column
                    if (targetColumn) {
                        targetColumn.classList.add('drag-over');
                    }
                }, { passive: true });

                card.addEventListener('touchend', e => {
                    if (!draggedCard) return;
                    
                    const touch = e.changedTouches[0];
                    const elementAtPoint = document.elementFromPoint(touch.clientX, touch.clientY);
                    const targetColumn = elementAtPoint?.closest('.column');
                    
                    if (targetColumn && draggedCard) {
                        const cardId = draggedCard.dataset.id;
                        const newStatus = targetColumn.dataset.column;
                        
                        const idea = allIdeas.find(i => i.id === cardId);
                        if (idea) {
                            idea.status = newStatus;
                            localStorage.setItem(`card-status-${cardId}`, newStatus);
                            
                            // Notify backend if moved to "writing"
                            if (newStatus === 'writing' && !idea.generated_content) {
                                notifyContentGeneration(idea);
                            }
                            
                            renderBoard();
                        }
                    }
                    
                    // Cleanup
                    draggedCard.classList.remove('dragging');
                    columns.forEach(col => col.classList.remove('drag-over'));
                    draggedCard = null;
                }, { passive: true });
            });

            // Mouse events for columns (desktop)
            columns.forEach(column => {
                column.addEventListener('dragover', e => {
                    e.preventDefault();
                    column.classList.add('drag-over');
                });

                column.addEventListener('dragleave', () => {
                    column.classList.remove('drag-over');
                });

                column.addEventListener('drop', e => {
                    e.preventDefault();
                    column.classList.remove('drag-over');
                    
                    if (draggedCard) {
                        const cardId = draggedCard.dataset.id;
                        const newStatus = column.dataset.column;
                        
                        const idea = allIdeas.find(i => i.id === cardId);
                        if (idea) {
                            idea.status = newStatus;
                            localStorage.setItem(`card-status-${cardId}`, newStatus);
                            
                            // Notify backend if moved to "writing"
                            if (newStatus === 'writing' && !idea.generated_content) {
                                notifyContentGeneration(idea);
                            }
                            
                            renderBoard();
                        }
                    }
                });
            });
        }

        async function notifyContentGeneration(idea) {
            // POST to queue server
            const request = {
                id: idea.id,
                call_id: idea.call_id,
                title: idea.title,
                format: idea.format,
                topic_detail: idea.details.topic_detail,
                hook: idea.details.hook,
                target_audience: idea.audience,
                priority_score: idea.priority,
                requested_at: Date.now()
            };
            
            try {
                const response = await fetch('http://localhost:18791/queue', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(request)
                });
                
                if (response.ok) {
                    console.log('‚úÖ Generation request queued:', idea.id);
                } else {
                    console.error('‚ùå Failed to queue request:', await response.text());
                }
            } catch (error) {
                console.error('‚ùå Error queuing request:', error);
            }
        }

        function startPolling() {
            // Check for generation requests every 30 seconds
            setInterval(checkGenerationRequests, 30000);
            checkGenerationRequests(); // Check immediately
        }

        async function checkGenerationRequests() {
            // Check status for all cards in "writing" state
            const writingCards = allIdeas.filter(i => i.status === 'writing' && !i.generated_content);
            
            for (const card of writingCards) {
                try {
                    const response = await fetch(`http://localhost:18791/status/${card.id}`);
                    const data = await response.json();
                    
                    if (data.status === 'complete' && data.content) {
                        console.log(`‚úÖ Content generated for: ${card.title}`);
                        card.generated_content = data.content;
                        card.status = 'review';
                        localStorage.setItem(`card-status-${card.id}`, 'review');
                        localStorage.setItem(`card-content-${card.id}`, data.content);
                    }
                } catch (error) {
                    // Queue server might not be running or content not ready yet
                }
            }
            
            if (writingCards.length > 0) {
                renderBoard();
            }
        }

        function updateStats() {
            const total = allIdeas.length;
            const writing = allIdeas.filter(i => i.status === 'writing').length;
            const review = allIdeas.filter(i => i.status === 'review').length;
            
            document.getElementById('stats').textContent = 
                `${total} content ideas ‚Ä¢ ${writing} in progress ‚Ä¢ ${review} awaiting review`;
        }

        loadContentIdeas();
    </script>
</body>
</html>
